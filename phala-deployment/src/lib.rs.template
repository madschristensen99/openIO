use wasm_bindgen::prelude::*;
use tfhe::{self, ConfigBuilder, ClientKey, ServerKey, CompactPublicKey};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[derive(Serialize, Deserialize)]
#[wasm_bindgen]
pub struct FheResponse {
    pub status: String,
    pub result: Option<String>,
    pub error: Option<String>,
}

#[derive(Serialize, Deserialize)]
#[wasm_bindgen]
pub struct FheInput {
    pub operation: String,
    pub data: String,
    pub timeout: Option<u32>,
}

#[wasm_bindgen]
pub struct FheProcessor {
    client_key: Option<ClientKey>,
    server_key: ServerKey,
    public_key: CompactPublicKey,
}

#[wasm_bindgen]
impl FheProcessor {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        let config = ConfigBuilder::with_custom_parameters(
            tfhe::shortint::prelude::PARAM_MESSAGE_2_CARRY_2
        ).build();
        
        let client_key = ClientKey::generate(config);
        let server_key = ServerKey::new(&client_key);
        let public_key = CompactPublicKey::new(&client_key);
        
        FheProcessor {
            client_key: Some(client_key),
            server_key,
            public_key,
        }
    }

    #[wasm_bindgen]
    pub fn process(&mut self, input: &str) -> String {
        let parsed: Result<FheInput, _> = serde_json::from_str(input);
        
        match parsed {
            Ok(fhe_input) => {
                let response = match fhe_input.operation.as_str() {
                    "encrypt" => self.encrypt_data(&fhe_input.data),
                    "decrypt" => self.decrypt_data(&fhe_input.data),
                    "compute" => self.compute_on_encrypted(&fhe_input.data),
                    _ => FheResponse {
                        status: "error".to_string(),
                        result: None,
                        error: Some("Invalid operation".to_string()),
                    },
                };
                
                serde_json::to_string(&response).unwrap_or_else(|_| {
                    "{\"status\":\"error\",\"result\":null,\"error\":\"Serialization failed\"}".to_string()
                })
            }
            Err(_) => {
                "{\"status\":\"error\",\"result\":null,\"error\":\"Invalid input format\"}".to_string()
            }
        }
    }

    fn encrypt_data(&self, data: &str) -> FheResponse {
        FheResponse {
            status: "success".to_string(),
            result: Some(format!("encrypted_{}", data)),
            error: None,
        }
    }

    fn decrypt_data(&self, data: &str) -> FheResponse {
        FheResponse {
            status: "success".to_string(),
            result: Some(format!("decrypted_{}", data)),
            error: None,
        }
    }

    fn compute_on_encrypted(&self, data: &str) -> FheResponse {
        FheResponse {
            status: "success".to_string(),
            result: Some(format!("computed_{}", data)),
            error: None,
        }
    }
}

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

#[wasm_bindgen(start)]
pub fn main() {
    console_error_panic_hook::set_once();
    log("FHE Processor initialized");
}